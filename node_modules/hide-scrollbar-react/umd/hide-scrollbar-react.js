/*!
 * hide-scrollbar-react v1.1.6 - https://github.com/exilee20c/hide-scrollbar-react#readme
 * MIT Licensed
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["_exl_scrollable"] = factory(require("react"));
	else
		root["_exl_scrollable"] = factory(root["React"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(4);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 3 */,
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_ = __webpack_require__(0);
var external_root_React_commonjs2_react_commonjs_react_amd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_);

// EXTERNAL MODULE: ./src/Scrollable/Scrollable.scss
var Scrollable_Scrollable = __webpack_require__(2);

// CONCATENATED MODULE: ./src/Scrollable/Scrollable.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var Scrollable_Scrollable_Scrollable = function (_Component) {
  _inherits(Scrollable, _Component);

  function Scrollable() {
    var _temp, _this, _ret;

    _classCallCheck(this, Scrollable);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
      // 스크롤 썸이 보이는지 여부 ( 스크롤시, 마우스 진입시 1.2초간 노출 )
      is_appear: false,
      scroll_disappear_timing: 0,

      // 스크롤 썸 위치 제어를 위한 scrollTop 수치값 추적
      scroll_top: 0,

      // 리사이즈, 스크롤 등에서 스크롤 너비 높이를 다시 계산하기 위한 증분 (re-render 유도)
      resize_cursor: 0,

      // 드래그앤드롭을 이용한 스크롤링, 스크롤 썸이 눌렸는지 식별
      is_thumb_pressed: false,

      // 맨위 && 맨아래보다 밖으로 갔다가 돌아왔을 때, 스크롤썸에 대한 위치 유지를 위한 값
      // 스크롤이 시작하기 전 스크롤이 어느정도였는지
      thumb_press_origin_scroll_top: 0,

      // 스크롤이 시작된 x 좌표는? > +-100 , 초기 스크롤 복원
      thumb_press_origin_x: 0,

      // 스크롤썸의 어느 좌표에서 클릭되어 드래그가 시작됐는가
      thumb_press_origin_y_of: 0
    }, _this.scrollChanged = function (event) {
      if (_this.state.scroll_disappear_timing) {
        window.clearTimeout(_this.state.scroll_disappear_timing);
      }

      _this.setState({
        scroll_top: event.currentTarget.scrollTop,
        is_appear: true,
        resize_cursor: _this.state.resize_cursor + 1
      });

      var timeout = window.setTimeout(function () {
        return _this.setState({ is_appear: false });
      }, 1200);

      _this.setState({ scroll_disappear_timing: timeout });
    }, _this.windowSizeChanged = function (event) {
      _this.setState({
        resize_cursor: _this.state.resize_cursor + 1
      });
    }, _this.mouseScrollStart = function (event) {
      event.stopPropagation();

      // 썸 클릭시 --> 썸의 상대적 위치 기억 후 드래그 대응
      if (_this.refs.scrollbar_inner === document.elementFromPoint(event.clientX, event.clientY)) {
        _this.setState({
          is_thumb_pressed: true,
          thumb_press_origin_scroll_top: _this.refs.scrollable_outer.scrollTop,

          thumb_press_origin_x: event.clientX,
          thumb_press_origin_y_of: event.clientY - _this.refs.scrollbar_inner.getBoundingClientRect().top
        });
      }

      // 바 클릭시 --> 썸의 가운데 위치 기억 후 드래그 대응
      else {
          event.persist();

          _this.setState({
            is_thumb_pressed: true,
            thumb_press_origin_scroll_top: _this.refs.scrollable_outer.scrollTop,

            thumb_press_origin_x: event.clientX,
            thumb_press_origin_y_of: _this.refs.scrollbar_inner.getBoundingClientRect().height / 2
          }, function () {
            return _this.mouseMove(event);
          });
        }
    }, _this.mouseScrollEnd = function (event) {
      _this.setState({
        is_thumb_pressed: false,
        thumb_press_origin_scroll_top: _this.refs.scrollable_outer.scrollTop,

        thumb_press_origin_x: 0,
        thumb_press_origin_y_of: 0
      });
    }, _this.mouseMove = function (event) {
      if (event.buttons && _this.state.is_thumb_pressed) {
        if (_this.refs) {
          var the_scale_amt = _this.refs.scrollbar_outer.getBoundingClientRect().height / _this.refs.scrollbar_inner.getBoundingClientRect().height;

          if (_this.refs.scrollbar_outer && _this.refs.scrollbar_inner && _this.refs.scrollable_outer) {
            if (Math.abs(event.clientX - _this.state.thumb_press_origin_x) > 100) {
              _this.refs.scrollable_outer.scrollTop = _this.state.thumb_press_origin_scroll_top;
            } else {
              _this.refs.scrollable_outer.scrollTop = the_scale_amt * (event.clientY - _this.state.thumb_press_origin_y_of - _this.refs.scrollbar_outer.getBoundingClientRect().top);
            }
          }
        }
      } else {
        _this.mouseScrollEnd(event);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Scrollable.prototype.render = function render() {
    var scrollable_outer_height = void 0,
        scrollable_inner_height = void 0,
        scrollbar_outer_height = void 0,
        scrollbar_inner_height = void 0,
        scrollbar_inline_height = void 0,
        scrollbar_inline_top = void 0;

    if (this.refs) {
      if (this.refs.scrollable_outer) {
        scrollable_outer_height = this.refs.scrollable_outer.getBoundingClientRect().height;
      }
      if (this.refs.scrollable_inner) {
        scrollable_inner_height = this.refs.scrollable_inner.getBoundingClientRect().height;
      }
      if (this.refs.scrollbar_outer) {
        scrollbar_outer_height = this.refs.scrollbar_outer.getBoundingClientRect().height;
      }
      if (this.refs.scrollbar_inner) {
        scrollbar_inner_height = this.refs.scrollbar_inner.getBoundingClientRect().height;
      }
    }

    scrollbar_inline_height = scrollable_inner_height > scrollable_outer_height ? scrollable_outer_height / scrollable_inner_height * scrollbar_outer_height : scrollbar_outer_height;

    scrollbar_inline_top = (scrollbar_outer_height - scrollbar_inline_height) * (this.state.scroll_top / (scrollable_inner_height - scrollable_outer_height));

    return external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
      "section",
      { className: "exl-scrollable", style: this.props.style },
      external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
        "div",
        {
          className: "exl-scrollable-container",
          style: this.props.inner_style,
          ref: "scrollable_outer",
          onMouseEnter: this.scrollChanged,
          onScroll: this.scrollChanged
        },
        external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
          "div",
          { className: "exl-scrollable-content", ref: "scrollable_inner" },
          this.props.children
        )
      ),
      external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
        "div",
        {
          className: "exl-scrollable-scrollbar-wrapper" + (scrollable_inner_height > scrollable_outer_height ? this.state.is_appear ? " appear" : "" : " disappear"),
          ref: "scrollbar_outer",
          onMouseDown: this.mouseScrollStart
        },
        external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", {
          className: "exl-scrollable-scrollbar-thumb",
          ref: "scrollbar_inner",
          style: {
            height: scrollbar_inline_height + "px",
            top: scrollbar_inline_top + "px"
          },
          onMouseDown: this.mouseScrollStart
        })
      )
    );
  };

  Scrollable.prototype.componentDidMount = function componentDidMount() {
    window.addEventListener("resize", this.windowSizeChanged);
    window.addEventListener("mousemove", this.mouseMove);
  };

  Scrollable.prototype.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener("resize", this.windowSizeChanged);
    window.removeEventListener("mousemove", this.mouseMove);
  };

  return Scrollable;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_["Component"]);

/* harmony default export */ var src_Scrollable_Scrollable = (Scrollable_Scrollable_Scrollable);
// CONCATENATED MODULE: ./src/Scrollable/index.js

// CONCATENATED MODULE: ./src/index.js
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "default", function() { return src_Scrollable_Scrollable; });


/***/ })
/******/ ])["default"];
});