"use strict";

exports.__esModule = true;

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

require("./Scrollable.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Scrollable = function (_Component) {
  _inherits(Scrollable, _Component);

  function Scrollable() {
    var _temp, _this, _ret;

    _classCallCheck(this, Scrollable);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
      // 스크롤 썸이 보이는지 여부 ( 스크롤시, 마우스 진입시 1.2초간 노출 )
      is_appear: false,
      scroll_disappear_timing: 0,

      // 스크롤 썸 위치 제어를 위한 scrollTop 수치값 추적
      scroll_top: 0,

      // 리사이즈, 스크롤 등에서 스크롤 너비 높이를 다시 계산하기 위한 증분 (re-render 유도)
      resize_cursor: 0,

      // 드래그앤드롭을 이용한 스크롤링, 스크롤 썸이 눌렸는지 식별
      is_thumb_pressed: false,

      // 맨위 && 맨아래보다 밖으로 갔다가 돌아왔을 때, 스크롤썸에 대한 위치 유지를 위한 값
      // 스크롤이 시작하기 전 스크롤이 어느정도였는지
      thumb_press_origin_scroll_top: 0,

      // 스크롤이 시작된 x 좌표는? > +-100 , 초기 스크롤 복원
      thumb_press_origin_x: 0,

      // 스크롤썸의 어느 좌표에서 클릭되어 드래그가 시작됐는가
      thumb_press_origin_y_of: 0
    }, _this.scrollChanged = function (event) {
      if (_this.state.scroll_disappear_timing) {
        window.clearTimeout(_this.state.scroll_disappear_timing);
      }

      _this.setState({
        scroll_top: event.currentTarget.scrollTop,
        is_appear: true,
        resize_cursor: _this.state.resize_cursor + 1
      });

      var timeout = window.setTimeout(function () {
        return _this.setState({ is_appear: false });
      }, 1200);

      _this.setState({ scroll_disappear_timing: timeout });
    }, _this.windowSizeChanged = function (event) {
      _this.setState({
        resize_cursor: _this.state.resize_cursor + 1
      });
    }, _this.mouseScrollStart = function (event) {
      event.stopPropagation();

      // 썸 클릭시 --> 썸의 상대적 위치 기억 후 드래그 대응
      if (_this.refs.scrollbar_inner === document.elementFromPoint(event.clientX, event.clientY)) {
        _this.setState({
          is_thumb_pressed: true,
          thumb_press_origin_scroll_top: _this.refs.scrollable_outer.scrollTop,

          thumb_press_origin_x: event.clientX,
          thumb_press_origin_y_of: event.clientY - _this.refs.scrollbar_inner.getBoundingClientRect().top
        });
      }

      // 바 클릭시 --> 썸의 가운데 위치 기억 후 드래그 대응
      else {
          event.persist();

          _this.setState({
            is_thumb_pressed: true,
            thumb_press_origin_scroll_top: _this.refs.scrollable_outer.scrollTop,

            thumb_press_origin_x: event.clientX,
            thumb_press_origin_y_of: _this.refs.scrollbar_inner.getBoundingClientRect().height / 2
          }, function () {
            return _this.mouseMove(event);
          });
        }
    }, _this.mouseScrollEnd = function (event) {
      _this.setState({
        is_thumb_pressed: false,
        thumb_press_origin_scroll_top: _this.refs.scrollable_outer.scrollTop,

        thumb_press_origin_x: 0,
        thumb_press_origin_y_of: 0
      });
    }, _this.mouseMove = function (event) {
      if (event.buttons && _this.state.is_thumb_pressed) {
        if (_this.refs) {
          var the_scale_amt = _this.refs.scrollbar_outer.getBoundingClientRect().height / _this.refs.scrollbar_inner.getBoundingClientRect().height;

          if (_this.refs.scrollbar_outer && _this.refs.scrollbar_inner && _this.refs.scrollable_outer) {
            if (Math.abs(event.clientX - _this.state.thumb_press_origin_x) > 100) {
              _this.refs.scrollable_outer.scrollTop = _this.state.thumb_press_origin_scroll_top;
            } else {
              _this.refs.scrollable_outer.scrollTop = the_scale_amt * (event.clientY - _this.state.thumb_press_origin_y_of - _this.refs.scrollbar_outer.getBoundingClientRect().top);
            }
          }
        }
      } else {
        _this.mouseScrollEnd(event);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Scrollable.prototype.render = function render() {
    var scrollable_outer_height = void 0,
        scrollable_inner_height = void 0,
        scrollbar_outer_height = void 0,
        scrollbar_inner_height = void 0,
        scrollbar_inline_height = void 0,
        scrollbar_inline_top = void 0;

    if (this.refs) {
      if (this.refs.scrollable_outer) {
        scrollable_outer_height = this.refs.scrollable_outer.getBoundingClientRect().height;
      }
      if (this.refs.scrollable_inner) {
        scrollable_inner_height = this.refs.scrollable_inner.getBoundingClientRect().height;
      }
      if (this.refs.scrollbar_outer) {
        scrollbar_outer_height = this.refs.scrollbar_outer.getBoundingClientRect().height;
      }
      if (this.refs.scrollbar_inner) {
        scrollbar_inner_height = this.refs.scrollbar_inner.getBoundingClientRect().height;
      }
    }

    scrollbar_inline_height = scrollable_inner_height > scrollable_outer_height ? scrollable_outer_height / scrollable_inner_height * scrollbar_outer_height : scrollbar_outer_height;

    scrollbar_inline_top = (scrollbar_outer_height - scrollbar_inline_height) * (this.state.scroll_top / (scrollable_inner_height - scrollable_outer_height));

    return _react2.default.createElement(
      "section",
      { className: "exl-scrollable", style: this.props.style },
      _react2.default.createElement(
        "div",
        {
          className: "exl-scrollable-container",
          style: this.props.inner_style,
          ref: "scrollable_outer",
          onMouseEnter: this.scrollChanged,
          onScroll: this.scrollChanged
        },
        _react2.default.createElement(
          "div",
          { className: "exl-scrollable-content", ref: "scrollable_inner" },
          this.props.children
        )
      ),
      _react2.default.createElement(
        "div",
        {
          className: "exl-scrollable-scrollbar-wrapper" + (scrollable_inner_height > scrollable_outer_height ? this.state.is_appear ? " appear" : "" : " disappear"),
          ref: "scrollbar_outer",
          onMouseDown: this.mouseScrollStart
        },
        _react2.default.createElement("div", {
          className: "exl-scrollable-scrollbar-thumb",
          ref: "scrollbar_inner",
          style: {
            height: scrollbar_inline_height + "px",
            top: scrollbar_inline_top + "px"
          },
          onMouseDown: this.mouseScrollStart
        })
      )
    );
  };

  Scrollable.prototype.componentDidMount = function componentDidMount() {
    window.addEventListener("resize", this.windowSizeChanged);
    window.addEventListener("mousemove", this.mouseMove);
  };

  Scrollable.prototype.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener("resize", this.windowSizeChanged);
    window.removeEventListener("mousemove", this.mouseMove);
  };

  return Scrollable;
}(_react.Component);

exports.default = Scrollable;
module.exports = exports["default"];